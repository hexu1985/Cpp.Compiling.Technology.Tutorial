### 常规动态库升级实践

在典型的实际应用场景中，动态库新次要版本的发布往往相当频繁。
通常人们极少预期次要版本升级会引发问题，特别是在供应商发布新代码前遵循严格测试流程的情况下。

大多数情况下，安装动态库的新次要版本应当是个相当简单顺畅的过程，例如直接替换新文件即可。

但无论新次要版本导致现有功能故障的概率多低，这种可能性依然存在。
为了能从容回退并恢复之前稳定运行的动态库版本，我们需要用更精细的方法来替代简单的文件替换操作。


**准备：软链接的灵活性**

根据定义，软链接是文件系统中的一个元素，它携带了一个包含指向另一个文件路径的字符串。

实际上，我们可以说软链接指向一个已存在的文件。在大多数情况下，操作系统会将软链接视为它指向的文件。
访问软链接并重定向到它所代表的文件所带来的性能损失可以忽略不计。

软链接可以轻松创建：

```bash  
$ ln -s <文件路径> <软链接路径>  
```  

它也可以被重定向以指向另一个文件：

```bash  
$ ln -s -f <新文件路径> <现有软链接路径>  
```  

最后，当不再需要时，软链接可以被删除：

```bash  
$ unlink <软链接路径>  
```

**准备：库SONAME与库文件名的区别**

Linux库命名规范所述，库文件名应遵循以下格式：

```
库文件名 = lib + <库名称> + .so + <库完整版本信息>
```

而Linux动态库的soname则定义为：

```
库soname = lib + <库名称> + .so + <仅包含库主版本号>
```

显然，soname与库文件名几乎相同，唯一区别在于：soname不携带完整的版本信息，仅包含动态库的主版本号。
正如后续内容所示，这一特性在动态库版本管理方案中扮演着至关重要的角色。


**结合软链接与SONAME的库升级方案**

软链接的灵活性使其非常适合动态库升级场景。以下指南描述了具体操作流程：

- 在实际动态库文件所在的目录中，会维护一个指向实际库文件的软链接。
- 该软链接的名称严格匹配其所指向库的SONAME。通过这种方式，软链接实际上承载了版本信息相对宽松的库名称（即仅包含主版本信息）。
- 原则上，客户端二进制文件几乎不会（仅在极特殊情况下）链接到携带完整版本信息的动态库文件名。相反，正如稍后将详细说明的，客户端二进制构建过程被特意设置为链接到库的SONAME。  
- 这一设计背后的逻辑相当简单：指定动态库的完整精确版本信息会带来过多不必要的限制，因为它将直接阻止链接同一库的任何更新版本。


**为便于开发场景而需额外配置的软链接**

在构建客户端二进制文件时，开发人员需要确定动态库在构建时的位置，这个过程应遵循"-L -l"规范。
虽然可以通过在"-l"参数后加冒号并指定具体文件名的方式向链接器传递精确的动态库文件名（或软链接/soname），例如：

```bash
$ gcc -shared <输入文件> -l:libxyz.so.1 -o <客户端二进制文件>
```

但行业惯例是仅传递不包含任何版本信息的库名称。例如：

```bash
$ gcc -shared <输入文件> -lm -ldl -lpthread -lxml2 -lxyz -o <客户端二进制文件>
```

这表示客户端二进制文件需要分别链接名为libm、libdl、libpthread、libxml2和libxyz的库。

因此，除了携带库soname的软链接外，通常还需要提供仅包含库名称加.so扩展名的软链接。

提供额外软链接的方式有多种。最具结构化的方法是通过软件包部署配置（pkg-config）实现；
另一种稍欠结构化的方式是在控制动态库构建的makefile部署目标中完成。
当然，也可以始终通过命令行手动创建软链接，或通过设置简单脚本自动实现。


#### 参考资料:
《高级C/C++编译技术》: 10.2.1 基于soname的版本控制方案

