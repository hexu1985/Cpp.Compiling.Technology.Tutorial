### 插件

随着动态链接技术的发展，其所带来的最重要概念可能就是插件。
这一概念本身理解起来并不困难，因为在日常生活中我们经常遇到大量类似场景，其中大部分并不需要任何技术背景。
插件概念的一个典型例子就是电钻及其多种钻头，用户可以根据具体需求或个人选择随时更换。

软件的插件概念遵循着相同的原理。本质上，存在一个主应用程序（或执行环境），它针对特定处理对象执行某种操作（例如，用于修改图片属性的照片处理应用程序）；
同时还有一系列模块，专门用于对处理对象执行非常具体的操作（例如，模糊滤镜、锐化滤镜、棕褐色调滤镜、色彩对比度滤镜、高通滤镜、均值滤镜等），这一概念非常易于理解。

但这还不是全部。

并非所有由旗舰应用程序及相关模块组成的系统都配称为"插件架构"。一个架构要支持插件模型，还必须满足以下要求：

- 添加或移除插件时，不应要求重新编译应用程序；相反，应用程序应能在运行时检测插件的可用性。
- 模块应通过某种运行时可加载的机制来导出其功能。
- 无论最终用户在运行时能使用哪些插件，系统都应保持基本功能。

实际上，上述要求通常通过以下设计决策来实现：

- **插件实现为动态库**。无论内部功能如何，所有插件动态库都导出**标准化接口**（一组允许应用程序控制插件执行的函数）。
- **应用程序通过动态库加载过程来加载插件**。通常支持以下两种方式：
    + 应用程序扫描预定义文件夹，并尝试在运行时加载其发现的所有动态库。加载后，它会尝试查找与预期插件导出的接口相对应的符号。如果未找到符号（或仅找到部分符号），则卸载该插件库。
    + 用户在运行时通过专用的图形用户界面（GUI）选项，指定插件位置并指示应用程序加载插件，开始提供其功能。


**导出规则**

尽管不存在适用于所有插件架构的严格统一规则，但存在一套普遍遵循的常识性准则。
根据前文关于C++语言对链接器问题影响的阐述，大多数插件架构倾向于采用尽可能简单的方案：插件导出一个指向接口的指针，该接口由具有C链接的函数组成。

即使插件的内部功能可能以C++类实现，此类通常也会实现由其动态库容器导出的接口。
常见的做法是将指向该类实例的指针（转型为指向接口的指针）传递给应用程序。


#### 参考资料:
《高级C/C++编译技术》: 11.1 插件

